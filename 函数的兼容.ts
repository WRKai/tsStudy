const arr = [1, 2, 3, 4, 5]
// arr.forEach
// forEach的回调函数要求3个形参，然而你可以给0个形参的函数,1个形参的函数,2个形参的函数...
// 也就是说，反而是“少的”给“多的”没毛病
type F1 = (a: number) => void
type F2 = (a: number, b: number) => void
let func1: F1 = (a) => { }
let func2: F2 = (a, b) => { }
// func1=func2//多的给少的，报错
func2 = func1//少的给多的，没毛病
// 比较复杂的，加入参数本身的类型有接口定义，则需要考虑相反的，接口的兼容性。（把接口拆开来，再看参数数量）
//
//
// 考虑返回值，要求返回值类型一致。
// 返回值是复杂对象？那还是多给少